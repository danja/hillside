<html lang="en" class="no-js">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">
        html,
        body {
            margin: 0;
            height: 100%;
        }

        #c {
            z-index: -1;
            background: #000;
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
        }

        footer {
            background-color: #000000a0;
            grid-area: footer;
        }
    </style>
</head>

<body id="body">
    <canvas id="c"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-scale/0.0.2/scale.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3.1.0/dist/d3-scale-chromatic.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-force/0.0.3/d3-force.min.js"></script>
    <script>
        (() => {

            let distance = (e1, e2) => {
                return Math.sqrt((e1.x - e2.x) ** 2 + (e1.y - e2.y) ** 2);
            }
            //alert(window.innerWidth)
            let RAFID;
            let canvas = document.getElementById('c');
            let context = canvas.getContext('2d');
            let ww = document.getElementById('body').clientWidth;
            let hh = document.getElementById('body').clientHeight;
            let rect = canvas.getBoundingClientRect();
            let mx = ww / 2;
            let my = hh / 2;
            let handleMouseMove = (event) => {
                rect = canvas.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }
            document.onmousemove = handleMouseMove;
            let nodeCount = window.innerWidth > 1024 ? 600 : 300
            var sc = d3.scaleLinear()
                .domain([0, nodeCount])
                .range([0, 1])
            var color2 = d3.scaleSequential(d3.interpolateRainbow);
            let nodes = [];
            let links = [];

            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    id: i,
                    x: Math.random() * ww,
                    y: Math.random() * hh,
                    dx: 2 - (Math.random() * 4),
                    dy: 2 - (Math.random() * 4),
                    size: 1 + Math.random() * 3,
                    color: color2(sc(i))
                });
            }
            var collisionForce = d3.forceCollide((e) => { return e.size * 13 }).strength(.05).iterations(1);
            var collisionForce2 = d3.forceCollide((e) => { return e.size * 2 }).strength(.6).iterations(1);
            var attractForce = d3.forceManyBody().strength((e) => { return e.size });
            const center = d3.forceCenter(mx, my).strength(.163);
            const simulation = d3.forceSimulation(nodes)
                .force("collisionForce", collisionForce)
                .force("attractForce", attractForce)
                .force("center", center);

            let draw = () => {
                context.fillStyle = '#000';
                context.fillRect(0, 0, ww, hh);

                context.strokeStyle = '#ffffff80';
                context.lineWidth = .51;
                let indc = [];
                let t;
                let axi = 0;
                let ani = 0;
                nodes.map((e, i) => {
                    nodes.map((e2, i2) => {
                        e.size *= .999;
                        if (i !== i2) {
                            d = distance(e, e2);
                            if (d < 19 * (e.size + e2.size) && !indc[Math.max(i, i2) + '_' + Math.min(i, i2)]) {
                                indc[Math.max(i, i2) + '_' + Math.min(i, i2)] = true;
                                t = e.size < e2.size ? e : e2;
                                context.lineWidth = Math.min(e.vx, 2);
                                e.size += (.08 * e2.size) / d;
                                e2.size += (.08 * e.size) / d;
                                e.vx += (.41 * e2.vx) / Math.max(d, .01);
                                e.vy += (.41 * e2.vy) / Math.max(d, .01);
                                e2.vx += (.41 * e.vx) / Math.max(d, .01);
                                e2.vy += (.41 * e.vy) / Math.max(d, .01);
                                context.strokeStyle = t.color.replace(')', ',' + 2 / Math.log(d) + ')').replace('rgb', 'rgba');
                                context.beginPath();
                                context.moveTo(e.x, e.y);
                                context.lineTo(e2.x, e2.y);
                                context.stroke();
                            }
                        }

                        e2.size = Math.min(e2.size, 100);
                        e2.size = Math.max(e2.size, 1);

                        e.size = Math.max(e.size, 1);
                        e.size = Math.min(e.size, 100);
                    });
                });


                nodes.map((e) => {
                    context.beginPath();

                    context.fillStyle = "#000000aa";
                    context.arc(e.x + 1, e.y + 1, .45 * (Math.min(e.size, 2) * Math.min(Math.abs(e.vx * e.vy), 5)), 0, Math.PI * 2, true);
                    context.closePath();
                    context.fill();

                    context.beginPath();
                    context.fillStyle = e.color;

                    context.arc(e.x, e.y, .4 * Math.min(e.size, 2) * Math.min(Math.abs(e.vx * e.vy), 5), 0, Math.PI * 2, true);
                    context.closePath();
                    context.fill();

                })
                simulation.alpha(.5);
            }

            let animloop = () => {
                this.counter += .1;
                (window).cancelAnimationFrame(RAFID);
                RAFID = (window).requestAnimationFrame(() => animloop());
                if (context) {
                    draw();
                }
            }

            // Runs each time the DOM window resize event fires.
            // Resets the canvas dimensions to match window,
            // then draws the new borders accordingly.
            let resizeCanvas = () => {
                ww = document.getElementById('body').clientWidth;
                hh = document.getElementById('body').clientHeight;
                document.getElementById('c').width = ww;
                document.getElementById('c').height = hh;
                draw();
            }
            window.addEventListener('resize', resizeCanvas, false);
            resizeCanvas();
            animloop();
        })();
    </script>
</body>

</html>